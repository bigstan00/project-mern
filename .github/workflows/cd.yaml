name: CD
on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed

jobs:
  deploy:
    runs-on: self-hosted
    strategy:
      matrix:
        app: [frontend, backend]

    steps:
      - name: Set Environment Variables
        run: echo "APP=${{ matrix.app }}" >> $GITHUB_ENV

      - name: SSH to EC2 and Deploy
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets[format('{0}_EC2_HOST', env.APP)] }}
          username: ubuntu
          key: ${{ secrets[format('{0}_EC2_SSH_KEY', env.APP)] }}
          port: 22
          script: |
            # Check if Docker and Docker Compose are installed
            if command -v docker > /dev/null 2>&1; then
                echo "Docker is already installed. Skipping installation."
            else
                # Install Docker and Docker Compose
                sudo apt-get update
                sudo apt-get install -y ca-certificates curl

                # Add Docker's official GPG key
                sudo install -m 0755 -d /etc/apt/keyrings
                sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
                sudo chmod a+r /etc/apt/keyrings/docker.asc

                # Add Docker repository to sources
                echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] \
                https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
                sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

                sudo apt-get update
                sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

                # Enable Docker and add user to the Docker group
                sudo systemctl enable docker
                sudo systemctl start docker
                sudo usermod -aG docker $USER

                echo "Docker installation completed."
            fi

            # Check if NGINX is installed
            if command -v nginx > /dev/null 2>&1; then
                echo "NGINX is already installed. Skipping installation."
            else
                # Install NGINX
                sudo apt-get update
                sudo apt-get install -y nginx

                # Start and enable NGINX service
                sudo systemctl start nginx
                sudo systemctl enable nginx
                echo "NGINX installation completed."
            fi

            # Determine the application directory
            APP_DIR="/home/ubuntu/project-mern/${{ env.APP }}"
            
            # Clone or pull the latest code
            if [ ! -d "$APP_DIR" ]; then
                git clone https://github.com/bigstan00/project-mern $APP_DIR
            else
                cd $APP_DIR && git pull
            fi

            # Navigate to the application directory
            cd $APP_DIR

            # Stop any running containers
            docker compose down || { echo "Failed to stop running containers"; exit 1; }

            # Build and start containers in detached mode
            docker compose up -d --build || { echo "Failed to start containers"; exit 1; }

            # If it's the backend, setup cronjob for scaling
            if [ "${{ env.APP }}" == "backend" ]; then
                CRON_JOB="*/5 * * * * /home/ubuntu/project-mern/backend/scale.sh >> /home/ubuntu/project-mern/cron.log 2>&1"

                # Check if the cron job already exists
                if crontab -l | grep -Fxq "$CRON_JOB"; then
                    echo "Cron job already exists. Skipping setup."
                else
                    (crontab -l ; echo "$CRON_JOB") | crontab -
                    echo "Cron job added successfully."
                fi

                # Verify cronjob
                crontab -l  
            fi

            # Verify the running containers
            docker ps
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Allocate and Associate Elastic IP
        id: allocate_eip
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=mern-server-frontend" \
            --query "Reservations[*].Instances[*].InstanceId" --output text)

          if [ -z "$INSTANCE_ID" ]; then
            echo "Error: Unable to find instance." && exit 1
          fi

          CURRENT_IP=$(aws ec2 describe-addresses \
            --filters "Name=instance-id,Values=$INSTANCE_ID" \
            --query "Addresses[*].PublicIp" --output text)

          if [ -n "$CURRENT_IP" ]; then
            echo "Elastic IP already associated: $CURRENT_IP"
            echo "::set-output name=elastic_ip::$CURRENT_IP"
            exit 0
          fi

          echo "Allocating a new Elastic IP..."
          aws ec2 allocate-address --domain vpc --region us-east-2 --output json > eip.json
          ELASTIC_IP=$(jq -r '.PublicIp' eip.json)
          ALLOC_ID=$(jq -r '.AllocationId' eip.json)

          aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $ALLOC_ID --region us-east-2

          echo "::set-output name=elastic_ip::$ELASTIC_IP"

      - name: Validate Elastic IP
        run: |
          ELASTIC_IP="${{ steps.allocate_eip.outputs.elastic_ip }}"
          echo "Elastic IP to be used: $ELASTIC_IP"
          if [[ -z "$ELASTIC_IP" || ! "$ELASTIC_IP" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Invalid Elastic IP: '$ELASTIC_IP'" && exit 1
          fi

      - name: Update Route 53 Record
        run: |
          ELASTIC_IP="${{ steps.allocate_eip.outputs.elastic_ip }}"
          cat << EOF > route53.json
          {
            "Comment": "Update record to reflect new Elastic IP",
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "${{ secrets.AWS_DOMAIN_NAME }}",
                "Type": "A",
                "TTL": 300,
                "ResourceRecords": [{ "Value": "$ELASTIC_IP" }]
              }
            }]
          }
          EOF

          aws route53 change-resource-record-sets --hosted-zone-id ${{ secrets.AWS_HOSTED_ZONE_ID }} --change-batch file://route53.json